## 객체지향의 사실과 오해
부록A 추상화 기법 (p.229 ~ p.250)

---

### P.241

크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는  
`100% 규칙`과 `Is-a 규칙`을 준수해야 한다고 말한다.[Larman 2004].

100$% 규칙 : 슈퍼타입의 정의가 100% 서브타입에 적용되어야만 한다.  
서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.

Is-a 규칙 : 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다.  
이는 대개 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만듦으로써 테스트할 수 있다.

---

### P.242

클래스 간의 상속 관계를 반드시 일반화 관계라고 할 수는 없다.

일반화의 원칙ㄱ은 한 타입이 다른 타입의 서브타입이 되기 위해서 슈퍼타입에 순응해야 한다는 것이다.

순응에는 구조적인 순응과 행위적인 순응의 두 가지 종류가 있다.

구조적인 순응의 경우 기대 집합은 속성과 연관관계에 관한 것이며,  
(타입의 내연과 관련된 100% 규칙을 의미한다.)  
행위적인 순응의 경우 기대 집합은 행위가 동일한 계약을 기반으로 하느냐에 관한 것이다.
(타입의 행위에 관한 것으로, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다.)

---

### P.243

상속은 서브타이핑과 서브클래싱의 두 가지 용도로 사용될 수 있다.

서브클래스가 슈퍼클래스를 대체할 수 있는 경우 이를 서브타이핑이라고 한다.  
서브클래스가 슈퍼클래스를 대체할 수 없는 경우 이를 서브클래싱이라고 한다.

서브타이핑은 설계의 유연성이 목표인 반면 서브플래싱은 코드의 중복 제거와 재사용이 목적이다.  
흔히 서브타이핑을 인터페이스 상속이라고 하고, 서브클래싱을 구현 상속이라고 한다.

가능한 모든 상속 관계가 서브타이핑의 대체 가능성을 준수하도록 주의 깊게 사용하는 것은 코드를 유연하게 만들고 재사용성을 높이는 한 가지 방법이다.

---

### P.249

패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다.

개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있다.

함께 협력하는 응집도 높은 클래스 집합을 하나의 패키지 내부로 모으면 코드를 이해하기 위해 패키지 경계를 넘나들 필요가 적어진다.