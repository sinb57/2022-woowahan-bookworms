## 객체지향의 사실과 오해
7장 함께 모으기 (p.219 ~ p.228)

---

### P.222

구현하지 않고 머릿속으로만 구상한 설계는 코드로 구현하는 단계에서 대부분 변경된다.

중요한 것은 설계가 아니라 코드다.

코드를 통한 피드백 없인느 깔끔한 설계를 얻을 수 없다.

---

### P.223

객체의 속성은 객체의 내부 구현에 속하기 때문에 캡슐화돼야 한다.

객체에게 책임을 할당하고 인터페이스를 결정할 때는 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 말아야 한다.

객체가 어떤 책임을 수행햏야 하는지를 결정한 후에야 책임을 수행하는 데 필요한 객체의 속성을 결정하라.

---

### P.225

설계를 간단히 끝내고 최대한 빨리 구현에 돌입하라. 머릿속에 객체의 협력 구조가 번뜩인다면 그대로 코드를 구현하기 시작하라.

설계가 제대로 그려지지 않는다면 고민하지 말고 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라.

테스트-주도 설계로 코드를 구현하는 사람들이 하는 작업이 바로 이것이다.

그들은 테스트 코드를 작성해 가면서 협력을 설계한다.

---

### 개념 관점에서의 코드

소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다.

소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁으면 좁을수록 기능을 변경하기 위해 뒤적거려야 하는 코드의 양도 점점 줄어든다.

---

### 명세 관점에서의 코드

인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에게 영향을 미칠 수밖에 없다.

최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.

변화에 탄력적인 인터페이스를 만들 수 있는 능력은 객체지향 설계자의 수준을 가늠하는 중요한 척도이다.

---

### 구현 관점에서의 코드

메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안된다.  
(원칙적이라는 말 속에는 현실적으로 100% 파급효과가 미치는 것을 막는 것이 불가능한 경우도 있다는 사실을 암시한다.)

메서드와 속성은 클래스 내부의 비밀이다.

외부의 클래스는 자신이 협력하는 다른 클래스의 비밀 때문에 우왕좌왕해서는 안된다.

---

### 인터페이스와 구현을 분리하라

명세 관점은 클래스의 안정적인 측면을 드러내야 한다.  
구현 관점은 클래스의 불안정한 측면을 드러내야 한다.  
인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻을 수밖에 없다.

중요한 것은 여러분이 클래스를 봤을 때 클래스를 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다는 것이다.  
캡슐화를 위반해서 구현을 인터페이스 밖으로 노출해서도 안되고, 인터페이스와 구현을 명확하게 분리하지 않고 흐릿하게 섞어놓아서도 안된다.  
결국 세 가지 관점 모두에서 클래스를 바라볼 수 있으려면 훌륭한 설계가 뒷받침돼야 하는 것이다.