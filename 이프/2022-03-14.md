## 객체지향의 사실과 오해
4장 이상한 나라의 객체 (p.106 ~ p.137)

### 협력은 다수의 연쇄적인 요청과 응답의 흐름이다.

협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작되며,  
도움을 요청받은 사람 역시 자신에게 주어진 일을 처리하던 중 다른 사람에게 도움을 요청할 수 있다.

`협력`은 다수의 요청과 응답으로 구성되며, 전체적으로 협력은 `다수의 연쇄적인 요청과 응답의 흐름`으로 구성된다.

<br>

### 책임은 객체의 공용 인터페이스이다.

책임은 객체에 의해 정의되는 응집도 있는 행위의 집합으로,  
`객체가 무엇을 알고 있는가(knowing)`와 `무엇을 할 수 있는가(doing)`으로 구성된다.

객체의 책임을 이야기할 때는 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기한다.

이러한 관점에서 책임은 객체의 외부에 제공해 줄 수 있는 `정보`(아는 것의 측면)과  
외부에 제공해 줄 수 있는 `서비스`(하는 것의 측면)의 목록이다.

<br>

### 메시지는 협력에 참여하는 두 객체 사이의 관계를 강조한 것이다.

협력 안에서 객체는 다른 객체로부터 요청이 전송됐을 경우에만 자신에게 주어진 책임을 수행한다.

따라서 두 객체 간의 협력은 메시지를 통해 이뤄진다.

메시지는 협력을 위해 한 객체가 다른 객체로 접근할 수 있는 유일한 방법이다.

책임이 협력이라는 문맥 속에서 요청을 수신하는 한 쪽의 객체 관점에서 무엇을 할 수 있는지 나열하는 것이라면  
메시지는 협력에 참여하는 두 객체 사이의 관계를 강조한 것이다.

<br>

### 책임과 메시지의 수준은 같지 않다.

책임은 객체가 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다.

책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 `하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.` 

<br>

### 객체지향 설계에서 주의해야 할 점

> (p.118) 설계를 시작하는 초반에는 어떤 객체가 어떤 책임을 가지고 어떤 방식으로 서로 협력해야 하는지에 대한 개요를 아는 것만으로도 충분하다.
> 책임과 협력의 구조가 자리를 잡기 전까지는 책임을 구현하는 방법에 대한 고민은 잠시 뒤로 미루는 것이 좋다.
>
> (p.119) 객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작된다.
> 어떤 클래스가 필요하고 어ㄸ너 메서드를 포함해야 하는지를 결정하는 것은 책임과 메시지에 대한 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다.

<br>

### 역할은 대체 가능한, 책임의 집합이다.

`역할`은 `책임의 집합`이며, 협력 내에서 다른 객체로 `대체할 수 있음`을 나타내는 일종의 표식이다.

역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야 한다. (행동이 호환되어야 한다.)  
따라서 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정된다.

역할은 하나의 협력 안에서 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다.  
협력의 추상화는 설계자가 다뤄야 하는 협력의 개수를 줄이는 동시에 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화한다.  
이로써 역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있으며,  
다양한 객체들이 협력에 참여할 수 있기 때문에 재사용성도 높아진다.

구체적인 객체로 추상적인 역할을 대체해서 동일한 구조의 협력을 다양한 문맥에서 재사용할 수 있는 능력은  
과거의 전통적인 패러다임과 구분되는 객체지향만의 힘이다.

<br>

### 객체지향의 사실과 오해

1. 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다? (오해)
- 객체가 존재하는 이유는 행위를 수행하며 협력에 참여하기 위해서다.

2. 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다? (오해)
- 중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적인 객체이다.
- 객체지향의 핵심은 `클래스를 어떻게 구현할 것인가`가 아니라 `객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지` 결정하는 것이다.

<br>

### 올바른 객체지향 설계

객체지향 입문자들이 데이터나 클래스를 중심으로 애플리케이션을 설계하는 이유는  
협력이라는 문맥을 고려하지 않고 각 객체를 독립적으로 바라보기 때문이다.

> (p.129)
> 올바른 객체를 설계하기 위해서는 먼저 견고하고 깔끔한 협력을 설계해야 한다.  
> 협력을 선계한다는 것은 객체들이 주고받을 요청과 응답의 흐름을 결정한다는 것을 의미한다.  
> 이렇게 결정된 요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행될 책임이 된다.  
> 
> 객체에게 책임을 할당하고 나면 책임은 객체가 외부에 제공하게 될 행동이 된다.  
> 협력이라는 문맥에서 객체가 수행하게 될 적절한 책임, 즉 행동을 결정한 후에 그 행동을 수행하는데 필요한 데이터를 고민해야 한다.  
> 그리고 객체가 협력에 참여하기 위해 필요한 데이터와 행동이 어느 정도 결정된 후에 클래스의 구현 방법을 결정해야 한다.  
> 결과적으로 클래스와 데이터는 협력과 책임의 집합이 결정된 후에야 무대 위에 등장할 수 있다.

<br>

### 객체지향 설계 기법

1. 책임-주도 설계 (Responsibility-Driven Design)

객체지향 설계란 애플리케이션의 기능을 구현하기 위한 협력 관계를 고안하고,  
협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 잇는 적절한 객체를 식별해 나가는 과정이다.

책임-주도 설계는 개별적인 객체의 상태가 아니라 객체의 `책임`과 `상호작용`에 집중한다.

> (p.132) 객체지향 시스템을 설계하는 절차는 다음과 같다.  
> 시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다.  
> 객체가 책임을 수행하는 도중에 스스로 처리할 수 없는 정보나 기능이 필요한 경우, 적절한 객체를 찾아 필요한 작업을 요청한다.  
> 요청된 작업을 수행하는 일은 이제 작업을 위임받은 객체의 책임으로 변환된다.  
> 객체가 다른 객체에게 작업을 요청하는 행위를 통해 결과적으로 객체들 간의 협력 관계가 만들어진다.  
> 만약 책임을 여러 종류의 객체가 수행할 수 있다면 협력자는 객체가 아니라 추상적인 역할로 대체된다.

<br>

2. 디자인 패턴 (Design Pattern)

디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의된, 책임-주도 설계의 결과물이자 지름길이다.

<br>

3. 테스트-주도 개발 (Test-Driven Development)

테스트-주도 개발은 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것이지를 먼저 생각하고 진행해야 한다.

테스트-주도 개발은 테스트를 작성하는 것이 아니라, 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이  
메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.  

테스트-주도 개발은 책임-주도 설계의 기본 개념을 따르기 때문에,  
협력 안에서 객체의 역할과 책임이 무엇이고 이것이 어떻게 구현되어야 하는지에 대한 감각을 갖춰야만 효과적인 테스트를 작성할 수 있다.

테스트-주도 개발은 책임-주도 설계의 기본 개념과 다양한 원칙과 프랙티스, 패턴을 종합적으로 이해하고  
좋은 설계에 대한 감각과 경험을 길러야만 적용할 수 있는 설계 기법이다.
역할, 책임, 협렭에 집중하고 객체지향의 원칙을 적용하려는 깊이 있는 고민과 노력을 통해서만 테스트-주도 개발의 혜택을 누릴 수 있다.