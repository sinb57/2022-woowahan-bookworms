## 객체지향의 사실과 오해
3장 이상한 나라의 객체 (p.89 ~ p.105)

### 타입은 데이터가 아닌 행동에 의해 결정된다.

객체들의 내부 표현 방식이 다르더라도 동일하게 행동한다면, 그 객체들은 동일한 타입에 속한다.  
반면 객체가 서로 동일한 데이터를 갖고 있더라도 다른 행동을 한다면, 그 객체들은 서로 다른 타입이다.  

<br>

### 다형성

같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다.  
따라서 동일한 메시지를 서로 다른 데이터 표현 방식으로 처리한다.  

동일한 메시지를 서로 다른 방식으로 처리하기 위해서는 객체들이 동일한 메시지를 수신할 수 있어야 하기 때문에  
결과적으로 다형적인 객체들은 동일한 타입(또는 타입 계층)에 속하게 된다.  

<br>

### 캡슐화

데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다.  

데이터가 캡슐의 벽을 뚫고 객체의 인터페이스를 오염시키는 순간,  
객체의 분류 체계는 급격히 위험에 노출되고 결과적으로 유연하지 못한 설계를 낳는다.

<br>

### 일반화/특수화

객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이다.

두 타입 간에 일반화/특수화 관계가 성립하려면 한 타입이 다른 타입보다 더 특수하게 행동해야 하고  
반대로 한 타입은 다른 타입보다 더 일반적으로 행동해야 한다.

`일반적인 타입`이란 특수한 타입이 가진 모든 행동들 중에서 일부 행동만을 가지는 타입을 가리킨다.  
반대로 `특수한 타입`이란 일반적인 타입이 가진 모든 타입을 포함하지만  거기에 더해 자신만의 행동을 추가하는 타입을 가리킨다.  

`일반적인 타입`을 `슈퍼타입`이라 하며, `특수한 타입`을 `서브타입`이라 한다.

어떤 타입이 다른 타입의 `서브타입이` 되기 위해서는 행위적 호환성을 만족시켜야 한다.  
일반적으로 `서브타입`은 `슈퍼타입`의 행위와 호환되기 때문에 `서브타입`은 `슈퍼타입`으로 대체할 수 있어야 한다.  
따라서 어떤 타입을 다른 타입의 `서브타입`이라고 말할 수 있으려면 다른 타입을 대체할 수 있어야 한다.[Liskov 1988]

<br>

### 타입은 추상화이다.

타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 어렵기 때문이다.

객체는 시간에 따라 여러 행동을 취하며, 이에 따라 매번 상태가 변경된다.

타입은 시간에 따라 동적으로 변하는 객체의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 한다.

이런 관점에서 타입은 추상화이다. `시간`이라는 요소와 `상태 변화`라는 요소를 제거하고  
철저하게 정적인 관점에서 객체의 상태를 묘사하는 것이 가능하게 해준다.

결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법이다.



### 클래스는 타입을 구현하는 보편적인 방법이다.

클래스와 타입은 동일하지 않다. 타입은 객체를 분류하기 위해 사용되는 개념이고,  
클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐이다.