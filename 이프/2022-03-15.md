## 객체지향의 사실과 오해
5장 책임과 메시지 (p.138 ~ p.161)

### 책임은 추상적이면서 구체적이어야 한다.

객체는 자율적이다. 따라서 객체에게 할당되는 책임의 수준 역시 자율적이어야 한다.

책임은 자율성을 보장할 수 있을 정도로 충분히 `추상적`이어야 하고,
그와 동시에 협력의 의도를 뚜렷하게 표현할 수 있을 정도로 충분히 `구체적`이어야 한다.

자율적인 책임의 특징은 객체가 `어떻게(how) 해야 하는가`가 아니라  
`무엇(what)을 해야 하는가`를 설명한다는 것이다.

책임은 해당 객체가 협력을 위해 `무엇을 해야 하는지` 결정하지만,
그 객체가 `어떻게 해야하는지` 결정하는 것은 자율에 맡긴다.

<br>

### 메시지는 책임을 결정한다.

객체가 다른 객체와 소통하기 위해 주고받는 요청을 `메시지`라고 부르며,  
`메시지`는 객체로 하여금 자신의 책임, 행동을 수행하게 만드는 유일한 방법이다.

근본적으로 메시지의 개념은 책임의 개념과 연결된다.  
송신자는 메시지 전송을 통해서만 다른 객체의 책임을 요청할 수 있고,  
수신자는 오직 메시지 수신을 통해서만 자신의 책임을 수행할 수 있다.  
즉, 객체가 수신할 수 있는 메시지의 모양이 객체가 수행할 책임의 모양을 결정한다.

객체의 외부와 내부는 메시지를 기분으로 분리된다.  
객체가 제공하는 메시지는 외부의 다른 객체가 볼 수 있는 공개된 영역에 속한다.  
그에 반해 메시지를 처리하기 위해 책임을 수행하는 방법은  
외부의 다른 객체가 볼 수 없는 객체 자신의 사적인 영역에 속한다.

<br>

### 다형성은 협력을 유연하게 만든다.

다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.

다형성에서 중요한 것은 메시지 송신자의 관점이다.

메시지 수신자들이 동일한 메시지를 서로 다른 방식으로 처리하더라도  
메시지 송신자의 관점에서는 결국, 이 객체들이 동일한 책임을 수행한 것이다.

따라서 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며,  
오로지 자신의 요청을 수행할 책임을 지니는지 여부를 바라보게 된다.

다형성은 메시지 송신자의 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있게 한다.

기본적으로 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 `대체 가능성`을 의미한다.  
비로 메시지를 처리하는 방법인 메서드가 달라지더라도, 동일한 메시지를 처리하기 때문에  
메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것이다.

다형성은 수신자의 종류를 캡슐화한다.  
송신자는 메시지를 처리할 수 있는 수신자라면, 그 수신자의 종류를 모르더라도 메시지를 송신할 수 있으며  
송신자에게 영향을 주지 않고도 메시지를 수신할 객체의 타입을 자유롭게 추가할 수 있다.

다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를  
메시지에 대한 결합도로 낮춤으로써 달성된다.

<br>

### 메시지를 따라라

객체지향 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의된다.[Metz 2012]

애플리케이션을 살아있게 만드는 것은 클래스가 아니라 객체다.  
이런 객체들의 윤곽을 결정하는 것이 바로 객체들이 주고받는 메시지다.

객체지향 패러다임으로의 전환은 시스템을 정적인 클래스들의 집합이 아니라  
메시지를 주고받는 동적인 객체들의 집합으로 바라보는 것에서 시작된다.  
클래스에 담길 객체들의 공통적인 행위와 속성을 포착하기 위해서는 먼저 협력하는 객체들의 관점에서 시스템을 바라봐야 한다.

객체의 행위를 고려하기 위해서는 객체를 독립된 단위가 아니라 협력이라는 문맥 안에서 생각해야 한다.  
협력 관계 속에서 다른 객체에게 무엇을 제공해야 하고 다른 객체로부터 무엇을 얻어야 하는가라는 관점에서 접근할 때만 훌륭한 책임을 수확할 수 있다.

훌륭한 객체지향 설계는 `어떤 객체가 어떤 메시지를 전송할 수 있는가`와  
`어떤 객체가 어떤 메시지를 이해할 수 있는가`를 중심으로 객체 사이의 협력 관계를 구성하는 것이다.

객체지향 설계의 중심에는 메시지가 위치한다.  
객체가 메시지를 선택하는 것이 아니라 `메시지가 객체를 선택하게 해야 한다.`

<br>

### What/Who 사이클

객체 사이의 협력 관계를 설계하기 위해서는 먼저 `어떤 행위(What)을 수행할 것인지`를 결정한 후에  
`누가(Who) 그 행위를 수행할 것인가`를 결정해야 한다.

협력이라는 문맥 안에서 필요한 메시지를 먼저 결정한 후에 메시지를 수신하기에 적합한 객체를 선택해야 한다.

What/Who 사이클은 `어떤 객체가 필요한지` 생각하지 말고 `어떤 메시지가 필요한지`를 먼저 고민하라고 조언한다.

<br>

### Tell, Don't Ask

메시지를 결정하는 시점에서는 어떤 객체가 메시지를 수신할 것인지를 알 수 없기 때문에  
당연히 메시지 송신자는 메시지를 수신할 객체의 내부 상태를 볼 수 없다.  
따라서 메시지 중심의 설계는 메시지 수신자의 캡슐화를 증진시키며, 송신자와 수신자 간의 결합을 느슨하게 한다.

객체는 다른 객체의 상태를 묻지 말아야 한다.  
단지 필요한 메시지를 전송하기만 하고, 메시지를 수신하는 객체가 스스로 메시지의 처리 방법을 결정하게 하라.  
결과적으로 `Tell, Don't Ask` 스타일은 객체를 자율적으로 만들고 캡슐화를 보장하며  
결합도를 낮게 유지시켜 주기 때문에 설계를 유연하게 만든다.




